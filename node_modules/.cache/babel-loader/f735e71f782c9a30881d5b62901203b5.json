{"ast":null,"code":"function _objectEntries(obj) {\n  var entries = [];\n  var keys = Object.keys(obj);\n\n  for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);\n\n  return entries;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React from 'react';\nimport { useImgixContext } from \"../HOCs\";\n/**\n * Merges the `src` object into the `destination` object. Destination values are\n * not overwritten by source values. Destination properties that resolve to\n * `undefined` or `null` are not overwritten if a destination value exists\n * unless destination key does not exist . It recursively merges the\n * `imgixParams` and `htmlAttributes` values.\n *\n * @param {Object} src - The Provider component's props object\n * @param {Object} destination - The child component's props object\n * @returns Object with the combined values from `src` & `destination` Objects\n *\n * @example\n *  const src = {\n *    width: 100,\n *    height: 200,\n *    imgixParams: { ar: \"1:2\", dpr: 2},\n *    htmlAttributes: { styles: \"width: 50\" }\n *  }\n *  const destination = {\n *    width: 101,\n *    height: 201,\n *    imgixParams: { dpr: 1 },\n *    htmlAttributes: { styles: \"width: 100\" }\n *  }\n *  const result = mergeProps(src, destination);\n *\n *  {\n *    width: 101,\n *    height: 201,\n *    imgixParams: { ar: \"1:2\", dpr: 1 },\n *    htmlAttributes: { styles: \"width: 100\" }\n *  }\n *\n */\n\nexport var mergeProps = function mergeProps(src, destination) {\n  if (src == null && destination !== null) {\n    return destination;\n  }\n\n  if (src !== null && destination == null) {\n    return src;\n  }\n\n  if (src == null && destination == null) {\n    return {};\n  }\n\n  var newProps = _objectSpread({}, destination);\n\n  var newPropKeys = Object.keys(newProps);\n\n  for (var _i = 0, _Object$entries = _objectEntries(src); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        k = _Object$entries$_i[0],\n        v = _Object$entries$_i[1];\n\n    if (newPropKeys.indexOf(k) == -1 && v !== null) {\n      newProps[k] = v;\n    } // recursively merge imgixParams and htmlAttributes\n\n\n    if (k === \"imgixParams\" || k === \"htmlAttributes\") {\n      if (v !== null) {\n        newProps[k] = mergeProps(src[k], newProps[k]);\n      }\n    }\n  }\n\n  return newProps;\n};\n/**\n * `mergeComponentPropsHOF` tries to invoke `React.useContext()`. If context is \n * `undefined`, context is being accessed outside of an `ImgixContext` provider \n * and the Component is returned as is.\n *\n * Otherwise, it merges a Component's props with the `ImgixContext` props and \n * return a Component with the merged `props`.\n * @param {React.Element <typeof Component} Component -  with defined `props`.\n * @returns Component with merged `props`.\n */\n\nexport var mergeComponentPropsHOF = function mergeComponentPropsHOF(Component) {\n  return function (props) {\n    var contextProps = useImgixContext();\n\n    if (contextProps == null) {\n      return /*#__PURE__*/React.createElement(Component, props);\n    }\n\n    var childProps = mergeProps(contextProps, props);\n    return /*#__PURE__*/React.createElement(Component, childProps);\n  };\n};","map":{"version":3,"sources":["../../src/HOFs/propMerger.js"],"names":["mergeProps","src","destination","newProps","newPropKeys","Object","k","v","mergeComponentPropsHOF","contextProps","useImgixContext","childProps"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAA,KAAA,MAAA,OAAA;AACA,SAAA,eAAA,QAAA,SAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMA,UAAU,GAAG,SAAbA,UAAa,CAAA,GAAA,EAAA,WAAA,EAAsB;AAC9C,MAAIC,GAAG,IAAHA,IAAAA,IAAeC,WAAW,KAA9B,IAAA,EAAyC;AACvC,WAAA,WAAA;AACD;;AACD,MAAID,GAAG,KAAHA,IAAAA,IAAgBC,WAAW,IAA/B,IAAA,EAAyC;AACvC,WAAA,GAAA;AACD;;AACD,MAAID,GAAG,IAAHA,IAAAA,IAAeC,WAAW,IAA9B,IAAA,EAAwC;AACtC,WAAA,EAAA;AACD;;AAED,MAAMC,QAAQ,GAAA,aAAA,CAAA,EAAA,EAAd,WAAc,CAAd;;AACA,MAAMC,WAAW,GAAGC,MAAM,CAANA,IAAAA,CAApB,QAAoBA,CAApB;;AAEA,OAAA,IAAA,EAAA,GAAA,CAAA,EAAA,eAAA,GAAqB,cAAA,CAArB,GAAqB,CAArB,EAAA,EAAA,GAAA,eAAA,CAAA,MAAA,EAAA,EAAA,EAAA,EAA0C;AAAA,QAAA,kBAAA,GAAA,cAAA,CAAA,eAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AAAA,QAA9BC,CAA8B,GAAA,kBAAA,CAAA,CAAA,CAAA;AAAA,QAA3BC,CAA2B,GAAA,kBAAA,CAAA,CAAA,CAAA;;AACxC,QAAIH,WAAW,CAAXA,OAAAA,CAAAA,CAAAA,KAA0B,CAA1BA,CAAAA,IAAgCG,CAAC,KAArC,IAAA,EAAgD;AAC9CJ,MAAAA,QAAQ,CAARA,CAAQ,CAARA,GAAAA,CAAAA;AAFsC,KAAA,CAIxC;;;AACA,QAAIG,CAAC,KAADA,aAAAA,IAAuBA,CAAC,KAA5B,gBAAA,EAAmD;AACjD,UAAIC,CAAC,KAAL,IAAA,EAAgB;AACdJ,QAAAA,QAAQ,CAARA,CAAQ,CAARA,GAAcH,UAAU,CAACC,GAAG,CAAJ,CAAI,CAAJ,EAASE,QAAQ,CAAzCA,CAAyC,CAAjB,CAAxBA;AACD;AACF;AACF;;AACD,SAAA,QAAA;AAzBK,CAAA;AA4BP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMK,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAA,SAAA,EAAA;AAAA,SAAe,UAAA,KAAA,EAAW;AAC9D,QAAMC,YAAY,GAAGC,eAArB,EAAA;;AACA,QAAID,YAAY,IAAhB,IAAA,EAA0B;AACxB,aAAA,aAAO,KAAA,CAAA,aAAA,CAAA,SAAA,EAAP,KAAO,CAAP;AACD;;AAED,QAAME,UAAU,GAAGX,UAAU,CAAA,YAAA,EAA7B,KAA6B,CAA7B;AACA,WAAA,aAAO,KAAA,CAAA,aAAA,CAAA,SAAA,EAAP,UAAO,CAAP;AAPoC,GAAA;AAA/B,CAAA","sourcesContent":["import React from 'react'\nimport { useImgixContext } from \"../HOCs\"\n\n/**\n * Merges the `src` object into the `destination` object. Destination values are\n * not overwritten by source values. Destination properties that resolve to\n * `undefined` or `null` are not overwritten if a destination value exists\n * unless destination key does not exist . It recursively merges the\n * `imgixParams` and `htmlAttributes` values.\n *\n * @param {Object} src - The Provider component's props object\n * @param {Object} destination - The child component's props object\n * @returns Object with the combined values from `src` & `destination` Objects\n *\n * @example\n *  const src = {\n *    width: 100,\n *    height: 200,\n *    imgixParams: { ar: \"1:2\", dpr: 2},\n *    htmlAttributes: { styles: \"width: 50\" }\n *  }\n *  const destination = {\n *    width: 101,\n *    height: 201,\n *    imgixParams: { dpr: 1 },\n *    htmlAttributes: { styles: \"width: 100\" }\n *  }\n *  const result = mergeProps(src, destination);\n *\n *  {\n *    width: 101,\n *    height: 201,\n *    imgixParams: { ar: \"1:2\", dpr: 1 },\n *    htmlAttributes: { styles: \"width: 100\" }\n *  }\n *\n */\nexport const mergeProps = (src, destination) => {\n  if (src == null && destination !== null) {\n    return destination\n  }\n  if (src !== null && destination == null) {\n    return src;\n  }\n  if (src == null && destination == null) {\n    return {}\n  }\n\n  const newProps = { ...destination }\n  const newPropKeys = Object.keys(newProps);\n\n  for (const [k, v] of Object.entries(src)) {\n    if (newPropKeys.indexOf(k) == -1 && v !== null) {\n      newProps[k] = v;\n    }\n    // recursively merge imgixParams and htmlAttributes\n    if (k === \"imgixParams\" || k === \"htmlAttributes\") {\n      if (v !== null) {\n        newProps[k] = mergeProps(src[k], newProps[k])\n      }\n    }\n  }\n  return newProps;\n}\n\n/**\n * `mergeComponentPropsHOF` tries to invoke `React.useContext()`. If context is \n * `undefined`, context is being accessed outside of an `ImgixContext` provider \n * and the Component is returned as is.\n *\n * Otherwise, it merges a Component's props with the `ImgixContext` props and \n * return a Component with the merged `props`.\n * @param {React.Element <typeof Component} Component -  with defined `props`.\n * @returns Component with merged `props`.\n */\nexport const mergeComponentPropsHOF = (Component) => (props) => {\n  const contextProps = useImgixContext();\n  if (contextProps == null) {\n    return <Component {...props} />\n  }\n\n  const childProps = mergeProps(contextProps, props);\n  return <Component {...childProps} />;\n}\n"]},"metadata":{},"sourceType":"module"}