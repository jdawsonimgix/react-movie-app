{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nimport React from \"react\";\nimport { withContentRect } from \"react-measure\";\nimport { PACKAGE_VERSION } from \"./constants\";\nimport constructUrl from \"./constructUrl\";\nimport extractQueryParams from \"./extractQueryParams\";\nimport findClosest from \"./findClosest\";\nimport targetWidths from \"./targetWidths\";\nimport { shallowEqual } from \"./common\";\n\nvar findNearestWidth = function findNearestWidth(actualWidth) {\n  return findClosest(actualWidth, targetWidths);\n};\n\nvar toFixed = function toFixed(dp, value) {\n  return +value.toFixed(dp);\n};\n\nexport var __shouldComponentUpdate = function __shouldComponentUpdate(props, nextProps) {\n  var contentRect = props.contentRect;\n  var bounds = contentRect.bounds;\n  var prevWidth = bounds.width,\n      prevHeight = bounds.height;\n  var nextContentRect = nextProps.contentRect;\n  var nextBounds = nextContentRect.bounds;\n  var nextWidth = nextBounds.width,\n      nextHeight = nextBounds.height; // If neither of the previous nor next dimensions are present,\n  // re-render.\n\n  if (!nextWidth || !nextHeight || !prevWidth || !prevHeight) {\n    return true;\n  } // The component has been rendered at least twice by this point\n  // and both the previous and next dimensions should be defined.\n  // Only update if the nextWidth is greater than the prevWidth.\n\n\n  if (prevWidth && nextWidth && nextWidth > prevWidth) {\n    return true;\n  } // Similarly, only update if the next height is greater than\n  // the previous height.\n\n\n  if (prevHeight && nextHeight && nextHeight > prevHeight) {\n    return true;\n  }\n\n  var customizer = function customizer(oldProp, newProp, key) {\n    // these keys are ignored from prop checking process\n    if (key === \"contextRect\" || key === \"measure\" || key === \"measureRef\") {\n      return true;\n    }\n\n    if (key === \"children\") {\n      return oldProp == newProp;\n    }\n\n    if (key === \"imgixParams\") {\n      return shallowEqual(oldProp, newProp, function (a, b) {\n        if (Array.isArray(a)) {\n          return shallowEqual(a, b);\n        }\n\n        return undefined;\n      });\n    }\n\n    if (key === \"htmlAttributes\") {\n      return shallowEqual(oldProp, newProp);\n    }\n\n    return undefined; // handled by shallowEqual\n  }; // If we made it here, we need to check if the \"top-level\"\n  // props have changed (e.g. disableLibraryParam).\n\n\n  var propsEqual = shallowEqual(props, nextProps, customizer);\n  return !propsEqual;\n};\n\nvar BackgroundImpl = /*#__PURE__*/function (_React$Component) {\n  _inherits(BackgroundImpl, _React$Component);\n\n  var _super = _createSuper(BackgroundImpl);\n\n  function BackgroundImpl(props) {\n    _classCallCheck(this, BackgroundImpl);\n\n    return _super.call(this, props);\n  }\n\n  _createClass(BackgroundImpl, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return __shouldComponentUpdate(this.props, nextProps);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          measureRef = _this$props.measureRef,\n          contentRect = _this$props.contentRect,\n          _this$props$imgixPara = _this$props.imgixParams,\n          imgixParams = _this$props$imgixPara === void 0 ? {} : _this$props$imgixPara,\n          onLoad = _this$props.onLoad,\n          disableLibraryParam = _this$props.disableLibraryParam,\n          src = _this$props.src,\n          children = _this$props.children,\n          _this$props$className = _this$props.className,\n          className = _this$props$className === void 0 ? \"\" : _this$props$className;\n      var forcedWidth = imgixParams.w,\n          forcedHeight = imgixParams.h;\n      var hasDOMDimensions = contentRect.bounds.width != null && contentRect.bounds.height != null;\n      var htmlAttributes = this.props.htmlAttributes || {};\n      var dpr = toFixed(2, imgixParams.dpr || global.devicePixelRatio || 1);\n      var ref = htmlAttributes.ref;\n\n      var onRef = function onRef(el) {\n        measureRef(el);\n\n        if (typeof ref === \"function\") {\n          ref(el);\n        }\n      };\n\n      var _ref = function () {\n        var bothWidthAndHeightPassed = forcedWidth != null && forcedHeight != null;\n\n        if (bothWidthAndHeightPassed) {\n          return {\n            width: forcedWidth,\n            height: forcedHeight\n          };\n        }\n\n        if (!hasDOMDimensions) {\n          return {\n            width: undefined,\n            height: undefined\n          };\n        }\n\n        var ar = contentRect.bounds.width / contentRect.bounds.height;\n        var neitherWidthNorHeightPassed = forcedWidth == null && forcedHeight == null;\n\n        if (neitherWidthNorHeightPassed) {\n          var _width = findNearestWidth(contentRect.bounds.width);\n\n          var _height = Math.ceil(_width / ar);\n\n          return {\n            width: _width,\n            height: _height\n          };\n        }\n\n        if (forcedWidth != null) {\n          var _height2 = Math.ceil(forcedWidth / ar);\n\n          return {\n            width: forcedWidth,\n            height: _height2\n          };\n        } else if (forcedHeight != null) {\n          var _width2 = Math.ceil(forcedHeight * ar);\n\n          return {\n            width: _width2,\n            height: forcedHeight\n          };\n        }\n      }(),\n          width = _ref.width,\n          height = _ref.height;\n\n      var isReady = width != null && height != null;\n\n      var commonProps = _objectSpread({}, htmlAttributes);\n\n      if (!isReady) {\n        return /*#__PURE__*/React.createElement(\"div\", _extends({}, commonProps, {\n          className: \"react-imgix-bg-loading \".concat(className),\n          ref: onRef\n        }), children);\n      }\n\n      var renderedSrc = function () {\n        var _extractQueryParams = extractQueryParams(src),\n            _extractQueryParams2 = _slicedToArray(_extractQueryParams, 2),\n            rawSrc = _extractQueryParams2[0],\n            params = _extractQueryParams2[1];\n\n        var srcOptions = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, params), {}, {\n          fit: \"crop\"\n        }, imgixParams), disableLibraryParam ? {} : {\n          ixlib: \"react-\".concat(PACKAGE_VERSION)\n        }), {}, {\n          width: width,\n          height: height,\n          dpr: dpr\n        });\n\n        return constructUrl(rawSrc, srcOptions);\n      }();\n\n      var style = _objectSpread(_objectSpread({}, htmlAttributes.style), {}, {\n        backgroundImage: \"url(\".concat(renderedSrc, \")\"),\n        backgroundSize: (htmlAttributes.style || {}).backgroundSize !== undefined ? htmlAttributes.style.backgroundSize : \"cover\"\n      });\n\n      return /*#__PURE__*/React.createElement(\"div\", _extends({}, commonProps, {\n        className: className,\n        ref: onRef,\n        style: style\n      }), children);\n    }\n  }]);\n\n  return BackgroundImpl;\n}(React.Component);\n\nvar Background = withContentRect(\"bounds\")(BackgroundImpl);\nexport { Background, BackgroundImpl as __BackgroundImpl };","map":{"version":3,"sources":["../src/react-imgix-bg.jsx"],"names":["findNearestWidth","findClosest","toFixed","value","__shouldComponentUpdate","contentRect","props","bounds","prevWidth","prevHeight","nextContentRect","nextProps","nextBounds","nextWidth","nextHeight","customizer","key","oldProp","shallowEqual","Array","propsEqual","BackgroundImpl","React","Component","measureRef","imgixParams","onLoad","disableLibraryParam","src","children","className","forcedWidth","forcedHeight","hasDOMDimensions","htmlAttributes","dpr","global","ref","onRef","width","height","bothWidthAndHeightPassed","undefined","ar","neitherWidthNorHeightPassed","Math","isReady","commonProps","renderedSrc","rawSrc","params","extractQueryParams","srcOptions","fit","ixlib","constructUrl","style","backgroundImage","backgroundSize","Background","withContentRect"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { withContentRect } from \"react-measure\";\nimport { PACKAGE_VERSION } from \"./constants\";\nimport constructUrl from \"./constructUrl\";\nimport extractQueryParams from \"./extractQueryParams\";\nimport findClosest from \"./findClosest\";\nimport targetWidths from \"./targetWidths\";\nimport { shallowEqual } from \"./common\";\n\nconst findNearestWidth = (actualWidth) =>\n  findClosest(actualWidth, targetWidths);\n\nconst toFixed = (dp, value) => +value.toFixed(dp);\n\nexport const __shouldComponentUpdate = (props, nextProps) => {\n  const contentRect = props.contentRect;\n  const bounds = contentRect.bounds;\n  const { width: prevWidth, height: prevHeight } = bounds;\n\n  const nextContentRect = nextProps.contentRect;\n  const nextBounds = nextContentRect.bounds;\n  const { width: nextWidth, height: nextHeight } = nextBounds;\n\n  // If neither of the previous nor next dimensions are present,\n  // re-render.\n  if (!nextWidth || !nextHeight || !prevWidth || !prevHeight) {\n    return true;\n  }\n\n  // The component has been rendered at least twice by this point\n  // and both the previous and next dimensions should be defined.\n  // Only update if the nextWidth is greater than the prevWidth.\n  if (prevWidth && nextWidth && nextWidth > prevWidth) {\n    return true;\n  }\n\n  // Similarly, only update if the next height is greater than\n  // the previous height.\n  if (prevHeight && nextHeight && nextHeight > prevHeight) {\n    return true;\n  }\n\n  const customizer = (oldProp, newProp, key) => {\n    // these keys are ignored from prop checking process\n    if (key === \"contextRect\" || key === \"measure\" || key === \"measureRef\") {\n      return true;\n    }\n\n    if (key === \"children\") {\n      return oldProp == newProp;\n    }\n\n    if (key === \"imgixParams\") {\n      return shallowEqual(oldProp, newProp, (a, b) => {\n        if (Array.isArray(a)) {\n          return shallowEqual(a, b);\n        }\n        return undefined;\n      });\n    }\n\n    if (key === \"htmlAttributes\") {\n      return shallowEqual(oldProp, newProp);\n    }\n\n    return undefined; // handled by shallowEqual\n  };\n\n  // If we made it here, we need to check if the \"top-level\"\n  // props have changed (e.g. disableLibraryParam).\n  const propsEqual = shallowEqual(props, nextProps, customizer);\n\n  return !(propsEqual);\n}\n\nclass BackgroundImpl extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return __shouldComponentUpdate(this.props, nextProps);\n  }\n\n  render() {\n    const {\n      measureRef,\n      contentRect,\n      imgixParams = {},\n      onLoad,\n      disableLibraryParam,\n      src,\n      children,\n      className = \"\",\n    } = this.props;\n    const { w: forcedWidth, h: forcedHeight } = imgixParams;\n    const hasDOMDimensions =\n      contentRect.bounds.width != null && contentRect.bounds.height != null;\n    const htmlAttributes = this.props.htmlAttributes || {};\n    const dpr = toFixed(2, imgixParams.dpr || global.devicePixelRatio || 1);\n    const ref = htmlAttributes.ref;\n    const onRef = (el) => {\n      measureRef(el);\n      if (typeof ref === \"function\") {\n        ref(el);\n      }\n    };\n\n    const { width, height } = (() => {\n      const bothWidthAndHeightPassed =\n        forcedWidth != null && forcedHeight != null;\n\n      if (bothWidthAndHeightPassed) {\n        return { width: forcedWidth, height: forcedHeight };\n      }\n\n      if (!hasDOMDimensions) {\n        return { width: undefined, height: undefined };\n      }\n      const ar = contentRect.bounds.width / contentRect.bounds.height;\n\n      const neitherWidthNorHeightPassed =\n        forcedWidth == null && forcedHeight == null;\n      if (neitherWidthNorHeightPassed) {\n        const width = findNearestWidth(contentRect.bounds.width);\n        const height = Math.ceil(width / ar);\n        return { width, height };\n      }\n      if (forcedWidth != null) {\n        const height = Math.ceil(forcedWidth / ar);\n        return { width: forcedWidth, height };\n      } else if (forcedHeight != null) {\n        const width = Math.ceil(forcedHeight * ar);\n        return { width, height: forcedHeight };\n      }\n    })();\n    const isReady = width != null && height != null;\n\n    const commonProps = {\n      ...htmlAttributes,\n    };\n\n    if (!isReady) {\n      return (\n        <div\n          {...commonProps}\n          className={`react-imgix-bg-loading ${className}`}\n          ref={onRef}\n        >\n          {children}\n        </div>\n      );\n    }\n\n    const renderedSrc = (() => {\n      const [rawSrc, params] = extractQueryParams(src);\n      const srcOptions = {\n        ...params,\n        fit: \"crop\",\n        ...imgixParams,\n        ...(disableLibraryParam ? {} : { ixlib: `react-${PACKAGE_VERSION}` }),\n        width,\n        height,\n        dpr,\n      };\n\n      return constructUrl(rawSrc, srcOptions);\n    })();\n\n    const style = {\n      ...htmlAttributes.style,\n      backgroundImage: `url(${renderedSrc})`,\n      backgroundSize:\n        (htmlAttributes.style || {}).backgroundSize !== undefined\n          ? htmlAttributes.style.backgroundSize\n          : \"cover\",\n    };\n\n    return (\n      <div {...commonProps} className={className} ref={onRef} style={style}>\n        {children}\n      </div>\n    );\n  }\n}\nconst Background = withContentRect(\"bounds\")(BackgroundImpl);\n\nexport { Background, BackgroundImpl as __BackgroundImpl };\n"]},"metadata":{},"sourceType":"module"}